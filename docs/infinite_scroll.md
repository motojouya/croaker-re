
# 無限スクロールの実装について

- 配列の並びの方向
- ロードする量
- ロードするタイミング

1度にロードする量は仮で20としたい
ロードするタイミングは、現状ロードされたものが描画されており、描画範囲が表示されていれば、その前後。

自分自信が描画されていなければ、その前の読み込みを削除する。
->それだと、微妙だね。3と4をいったり来たりする。

別のものが描画されたら、イベントとしてはそっちに移動して、不要なものを削除する感じになるかな。
でも、isIntersectingで状態っぽい感じになるのか。eventじゃなくて。
それならやはり描画されなくなったら、その前を削除がいいのかな。


画面上は、下が最新。
sqlで並び替えた順番どおりに並べたい。
でも、いずれにしろ、どちらかはreverseしないといけないのか。
基本的には、古い方を優先して表示が基本になるはず。
なので、新しい方は逆順できて、reverseして描画がいいか。

並びは、下から並べてく。なのでflex-col-reverseになる。
これなら、古いものは、単純に後ろに追加していく感じになる。

新しいものは、逆順にしてから頭に追加。

入力された値。という概念があるなぁ。
これは、現在ロードされた内容に、単純に突っ込む形でいいのか。
スクロールされた際に、削除さえしてくれればいい。
入力されたグループという配列を作っておいて、そこにpush。さらに、その前のグループを消す際には、同時に削除。という感じかな。

シンプルでいいか。
自分が見えたら、その前後があることを保証する。
なければロードする。

自分がロード中であれば、ロード完了後にその動きになる

自分自身がロードするという仕組みにすると、隣のロードが結構難しいな。
あるのかないのか、わからない。

こうだが
```
if (isIntersecting) {
  if (empty) {
    await loadSelf();
  }
  if (!loading) {
    loadSurround(firstCursor, lastCursor);
    // 分岐は関数内ですればいい。
    // 内部で前後を認識してロード
    // cursorを渡してあげないと、次のコンポーネントがロードすべき内容がわからない
    // 常にroot側で、状況を担保し、前後のコンポーネントがあることを保証する。また読み込みは自身でおこなう。
    // 追加したり、参照を消すだけだから、ここは同期関数でいけるはず。なので早いので大丈夫か
    // loadSelfは実際にhttpするので、そこだけは時間かかるけど、参照消えちゃえばそれは意味ないので大丈夫か
  }
} else {
  deleteSurround(firstCursor, lastCursor);
}
```

自分から見たら、news, before, self, after。この4つ
自分のrefは知っている。
4つの要素は可変なので、適切に与えてやる必要がある。

LinkedListのほうが実装がしやすそう。
LinkedListは実装しづらいはず。結局自分自信しかわからなくなっちゃうので。全体を知るためにはランダムアクセスのほうがいい

自分自身を示すkeyがいる。それがないと、配列上でどれを対象としていいかわからなくなってしまう。

newだけは、別の変数で管理。
ほかは配列で管理し、keyを与えてそれで特定する。
key固定じゃないと、reactがスクロール位置を覚えないので、一意に特的できるべきだな



とりあえずロジックはこれで行こうと思う。
見た目を先に整えるか。ロジックを忘れないうちに書くか。
ロジックかな


